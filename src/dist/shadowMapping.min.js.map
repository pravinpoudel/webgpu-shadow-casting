{"version":3,"sources":["shadowMapping.ts"],"names":["device","context","format","size","sphereVertexBuffer","sphereIndicesBuffer","boxVertexBuffer","boxIndicesBuffer","shaderBindGroup","_shadowPipeline","_MBuffer","_cameraViewMatrix","_CProjectionMatrix","_LmvpMatrix","_dLBuffer","_colorBuffer","sphere","require","box","math_1","gl_matrix_1","shadowV_wgsl_1","xCount","yCount","lightPosition","cameraPosition","x","y","z","eyePosition","vec3","fromValues","targetPosition","left","right","bottom","top","near","far","screenCanvas","document","getElementById","init","canvas","entry","navigator","gpu","console","warn","Error","requestAdapter","adapter","_a","sent","requestDevice","getContext","log","getPreferredCanvasFormat","width","clientWidth","window","devicePixelRatio","height","clientHeight","configure","initPipeline","_shaderPipelineDesc_VB","arrayStride","attributes","shaderLocation","offset","_shaderPipelineDesc_Primitive","topology","cullMode","_shaderPipelineDesc_depth","depthWriteEnabled","depthCompare","_vsShaderModule","createShaderModule","code","createRenderPipeline","label","layout","vertex","module","entryPoint","buffers","primitive","depthStencil","initVertexBuffer","createBuffer","byteLength","usage","GPUBufferUsage","VERTEX","COPY_DST","mappedAtCreation","Float32Array","getMappedRange","set","unmap","index","INDEX","Uint16Array","initInstancedBuffer","cameraProjectionMatrix","getProjectionMatrix","Math","PI","lightViewProjectionMatrix","mat4","create","ortho","lightViewMatrix","lookAt","multiply","viewMatrix","UNIFORM","STORAGE","mStagedArray","colorStagedArray","modelMatrices","Array","colorData","localPositionReference","count","i","j","random","translate","stages"],"mappings":"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","file":"shadowMapping.min.js","sourcesContent":["import * as sphere from \"./utils/sphere\";\r\nimport * as box from \"./utils/box\";\r\nimport { getModelViewMatrix, getProjectionMatrix } from \"./utils/math\";\r\nimport { vec3, mat4 } from \"gl-matrix\";\r\n\r\nimport _shadowVS from \"../shaders/shadowV.wgsl\";\r\nimport _shadowFS from \"../shaders/shadowF.wgsl\";\r\nimport _shadowDepth from \"../shaders/shadowDepth.wgsl\";\r\n\r\n// const canvas: HTMLCanvasElement;\r\nlet device: GPUDevice,\r\n  context: GPUCanvasContext,\r\n  format: GPUTextureFormat,\r\n  size: { width: number; height: number },\r\n  sphereVertexBuffer: GPUBuffer,\r\n  sphereIndicesBuffer: GPUBuffer,\r\n  boxVertexBuffer: GPUBuffer,\r\n  boxIndicesBuffer: GPUBuffer,\r\n  shaderBindGroup: GPUBindGroup,\r\n  _shadowPipeline: GPURenderPipeline,\r\n  _MBuffer: GPUBuffer,\r\n  _cameraViewMatrix: GPUBuffer,\r\n  _CProjectionMatrix: GPUBuffer,\r\n  _LmvpMatrix: GPUBuffer,\r\n  _dLBuffer: GPUBuffer,\r\n  _colorBuffer: GPUBuffer;\r\n\r\nconst xCount: number = 4;\r\nconst yCount: number = 4;\r\nconst lightPosition = [20.0, 100.0, 50.0];\r\nlet cameraPosition = { x: 0, y: 10, z: 10 };\r\nlet eyePosition = vec3.fromValues(\r\n  cameraPosition.x,\r\n  cameraPosition.y,\r\n  cameraPosition.z\r\n);\r\nlet targetPosition = vec3.fromValues(0, 0, 0);\r\n\r\n//orthographic projection dimension\r\nconst left = -40;\r\nconst right = 40;\r\nconst bottom = -40;\r\nconst top = 40;\r\nconst near = -50;\r\nconst far = 200;\r\n\r\nconst screenCanvas: HTMLCanvasElement = <HTMLCanvasElement>(\r\n  document.getElementById(\"main-screen\")\r\n);\r\n\r\nasync function init(canvas: HTMLCanvasElement) {\r\n  const entry: GPU = <GPU>navigator.gpu;\r\n  if (!entry) {\r\n    console.warn(\"webgpu is not supported in your browser !!!\");\r\n    throw new Error(\"webgpu is not supported\");\r\n  }\r\n  const adapter: GPUAdapter = <GPUAdapter>await entry.requestAdapter();\r\n  if (!adapter) {\r\n    throw new Error(\"adapter not found\");\r\n  }\r\n  device = await adapter.requestDevice();\r\n\r\n  if (!device) {\r\n    console.warn(\"no device found in the adapter\");\r\n  }\r\n\r\n  context = <GPUCanvasContext>canvas.getContext(\"webgpu\");\r\n  console.log(context);\r\n\r\n  if (!context) {\r\n    return;\r\n  }\r\n\r\n  // need to find what is this for ??\r\n  format = navigator.gpu.getPreferredCanvasFormat();\r\n  canvas.width = canvas.clientWidth * (window.devicePixelRatio || 1);\r\n  canvas.height = canvas.clientHeight * (window.devicePixelRatio || 1);\r\n  context.configure({\r\n    device: device,\r\n    format: \"bgra8unorm\",\r\n  });\r\n  size = { width: canvas.width, height: canvas.height };\r\n}\r\n\r\nasync function initPipeline() {\r\n  const _shaderPipelineDesc_VB = [\r\n    {\r\n      arrayStride: 8 * 4, // 3(position) + 3(normal) + 2(uv)\r\n      attributes: [\r\n        {\r\n          shaderLocation: 0,\r\n          offset: 0,\r\n          format: \"float32x3\",\r\n        },\r\n        {\r\n          shaderLocation: 1,\r\n          offset: 3 * 4,\r\n          format: \"float32x3\",\r\n        },\r\n        {\r\n          shaderLocation: 2,\r\n          offset: 6 * 4,\r\n          format: \"float32x2\",\r\n        },\r\n      ],\r\n    },\r\n  ];\r\n\r\n  const _shaderPipelineDesc_Primitive = {\r\n    topology: \"triangle-list\",\r\n    cullMode: \"back\",\r\n  };\r\n\r\n  const _shaderPipelineDesc_depth = {\r\n    depthWriteEnabled: true,\r\n    depthCompare: \"less\",\r\n    format: \"depth32float\",\r\n  };\r\n  const _vsShaderModule = device.createShaderModule({\r\n    code: _shadowVS,\r\n  });\r\n\r\n  _shadowPipeline = <GPURenderPipeline>await device.createRenderPipeline({\r\n    label: \"light View Depth Pipeline\",\r\n    layout: \"auto\",\r\n    vertex: {\r\n      module: _vsShaderModule,\r\n      entryPoint: \"main\",\r\n      buffers: _shaderPipelineDesc_VB,\r\n    } as GPUVertexState,\r\n    primitive: _shaderPipelineDesc_Primitive as GPUPrimitiveState,\r\n    depthStencil: _shaderPipelineDesc_depth as GPUDepthStencilState,\r\n  });\r\n}\r\n\r\nasync function initVertexBuffer() {\r\n  sphereVertexBuffer = device.createBuffer({\r\n    label: \"sphere vertex store buffer\",\r\n    size: sphere.vertex.byteLength,\r\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\r\n    mappedAtCreation: true,\r\n  });\r\n\r\n  var stagingData = new Float32Array(sphereVertexBuffer.getMappedRange());\r\n  stagingData.set(sphere.vertex);\r\n  sphereVertexBuffer.unmap();\r\n\r\n  sphereIndicesBuffer = device.createBuffer({\r\n    label: \"sphere indices store buffer\",\r\n    size: sphere.index.byteLength,\r\n    usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\r\n    mappedAtCreation: true,\r\n  });\r\n\r\n  var stagingData2 = new Uint16Array(sphereIndicesBuffer.getMappedRange());\r\n  stagingData2.set(sphere.index);\r\n  sphereIndicesBuffer.unmap();\r\n\r\n  boxVertexBuffer = device.createBuffer({\r\n    label: \"box vertex store buffer\",\r\n    size: box.vertex.byteLength,\r\n    usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\r\n    mappedAtCreation: true,\r\n  });\r\n\r\n  var stagingData = new Float32Array(boxVertexBuffer.getMappedRange());\r\n  stagingData.set(box.vertex);\r\n  boxVertexBuffer.unmap();\r\n\r\n  boxIndicesBuffer = device.createBuffer({\r\n    label: \"box indices store buffer\",\r\n    size: box.index.byteLength,\r\n    usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\r\n    mappedAtCreation: true,\r\n  });\r\n\r\n  var stagingData2 = new Uint16Array(boxIndicesBuffer.getMappedRange());\r\n  stagingData2.set(box.index);\r\n  boxIndicesBuffer.unmap();\r\n}\r\n\r\nasync function initInstancedBuffer() {\r\n  let cameraProjectionMatrix = getProjectionMatrix(\r\n    screenCanvas.width / screenCanvas.height,\r\n    0.5 * Math.PI,\r\n    0.1,\r\n    1000,\r\n    cameraPosition\r\n  );\r\n  // we will create and pass whole MVP of light\r\n  let lightViewProjectionMatrix = mat4.create();\r\n  mat4.ortho(lightViewProjectionMatrix, left, right, bottom, top, near, far); // it does as (40-(-40) in gl-matrix m4.ortho\r\n  let lightViewMatrix = mat4.create();\r\n  mat4.lookAt(\r\n    lightViewMatrix,\r\n    vec3.fromValues(lightPosition[0], lightPosition[1], lightPosition[2]),\r\n    targetPosition,\r\n    vec3.fromValues(0, 1, 0)\r\n  );\r\n  mat4.multiply(\r\n    lightViewProjectionMatrix,\r\n    lightViewProjectionMatrix,\r\n    lightViewMatrix\r\n  );\r\n\r\n  const viewMatrix = mat4.create();\r\n  mat4.lookAt(\r\n    viewMatrix,\r\n    eyePosition,\r\n    targetPosition,\r\n    vec3.fromValues(0, 0, 0)\r\n  );\r\n\r\n  _dLBuffer = device.createBuffer({\r\n    size: 3 * 4,\r\n    usage: GPUBufferUsage.UNIFORM,\r\n    mappedAtCreation: true,\r\n  });\r\n\r\n  var mappedArray = new Float32Array(_dLBuffer.getMappedRange());\r\n  mappedArray.set(lightPosition);\r\n  _dLBuffer.unmap();\r\n\r\n  var _cameraViewMatrix = device.createBuffer({\r\n    size: 16 * 4,\r\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\r\n    mappedAtCreation: true,\r\n  });\r\n\r\n  let viewMatrixStagingBuff = new Float32Array(\r\n    _cameraViewMatrix.getMappedRange()\r\n  );\r\n  viewMatrixStagingBuff.set(viewMatrix);\r\n  _cameraViewMatrix.unmap();\r\n\r\n  _CProjectionMatrix = device.createBuffer({\r\n    size: 16 * 4,\r\n    usage: GPUBufferUsage.UNIFORM,\r\n    mappedAtCreation: true,\r\n  });\r\n  var mappedArray = new Float32Array(_CProjectionMatrix.getMappedRange());\r\n  mappedArray.set(cameraProjectionMatrix);\r\n  _CProjectionMatrix.unmap();\r\n\r\n  _LmvpMatrix = device.createBuffer({\r\n    size: 16 * 4,\r\n    usage: GPUBufferUsage.UNIFORM,\r\n    mappedAtCreation: true,\r\n  });\r\n  var mappedLightArray = new Float32Array(_LmvpMatrix.getMappedRange());\r\n  mappedLightArray.set(lightViewProjectionMatrix);\r\n  _LmvpMatrix.unmap();\r\n\r\n  _MBuffer = device.createBuffer({\r\n    size: xCount * yCount * 16 * 4,\r\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n    mappedAtCreation: true,\r\n  });\r\n  let mStagedArray = new Float32Array(_MBuffer.getMappedRange());\r\n\r\n  _colorBuffer = device.createBuffer({\r\n    size: xCount * yCount * 4 * 4,\r\n    usage: GPUBufferUsage.UNIFORM,\r\n    mappedAtCreation: true,\r\n  });\r\n\r\n  let colorStagedArray = new Float32Array(_colorBuffer.getMappedRange());\r\n\r\n  const modelMatrices = new Array(xCount * yCount);\r\n  // const modelMatricesData = new Float32Array(xCount * yCount * 16 * 4);\r\n\r\n  const colorData = new Array(xCount * yCount);\r\n  // const colorDataSet = new Float32Array(xCount * yCount * 4);\r\n\r\n  {\r\n    let count = 0;\r\n    let localPositionReference = { x: 0, y: 0, z: 0 };\r\n    for (let i = 0; i < xCount; i++) {\r\n      for (let j = 0; j < yCount; j++) {\r\n        localPositionReference.x = -7.0 + Math.random() * 20.0;\r\n        localPositionReference.y = -10 + Math.random() * 25.0;\r\n        localPositionReference.z = -5 + Math.random() * 20;\r\n        modelMatrices[count] = mat4.create();\r\n        mat4.translate(\r\n          modelMatrices[count],\r\n          modelMatrices[count],\r\n          vec3.fromValues(\r\n            localPositionReference.x,\r\n            localPositionReference.y,\r\n            localPositionReference.z\r\n          )\r\n        );\r\n        mStagedArray.set(modelMatrices[count], 16 * count);\r\n        // modelMatricesData.set(modelMatrices[count], count * 16);\r\n        colorData[count] = [Math.random(), Math.random(), Math.random()];\r\n        colorStagedArray.set(colorData[count], count * 4);\r\n        count++;\r\n      }\r\n    }\r\n  }\r\n  _MBuffer.unmap();\r\n  _colorBuffer.unmap();\r\n}\r\n\r\nasync function stages() {\r\n  await init(screenCanvas);\r\n  await initPipeline();\r\n  await initVertexBuffer();\r\n  await initInstancedBuffer();\r\n}\r\n\r\nstages();\r\n// initShaderBuffer();\r\n\r\n//_shadowPipeline.setVertexBuffer(0, sphereVertexBuffer);\r\n\r\n//\r\n// // in sphere there is vertex count as well but that vertex count is number of vertex in that mesh not number of vec3\r\n// const sphereVertexBuffer = device.createBuffer({\r\n//     size: sphere.vertex.byteLength,\r\n//     usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\r\n//     mappedAtCreation: true\r\n// });\r\n\r\n// const sphereIndicesBuffer = device.createBuffer({\r\n//     size: sphere.index.byteLength,\r\n//     usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\r\n//     mappedAtCreation: true\r\n// });\r\n\r\n// const boxVertexBuffer = device.createBuffer({\r\n//     size: box.vertices.byteLength,\r\n//     usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\r\n//     mappedAtCreation: true\r\n// });\r\n\r\n// const boxIndicesBuffer = device.createBuffer({\r\n//     size: box.vertices.byteLength,\r\n//     usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\r\n//     mappedAtCreation: true\r\n// });\r\n\r\n// const sphereBuffer = {\r\n//     vertex:\r\n//     index:\r\n// }\r\n\r\n// const boxBuffer = {\r\n//     vertex:\r\n//     indices:\r\n// }\r\n\r\n// device.queue.writeBuffer(sphereBuffer.vertex, 0, sphereBuffer.vertex);\r\n// device.queue.writeBuffer(sphereBuffer.indices, 0, sphereBuffer.indices);\r\n// device.queue.writeBuffer(boxBuffer.vertex, 0, boxBuffer.vertex);\r\n// device.queue.writeBuffer(boxBuffer.indices, 0, boxBuffer.indices);\r\n"]}